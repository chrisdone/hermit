flatten-module

-- do the w/w split
consider 'hanoi
{ ww-split [| wrap |] [| unwrap |] }

{ consider 'work
  remember origwork

  any-call (unfold 'unwrap)

  -- establish the zero base case
  [ def-rhs, lam-body, lam-body, lam-body, lam-body]
  case-split-inline 'n
  { case-alt 0 ; any-call (unfold 'f) ; simplify }

  -- establish the one base case
  { [case-alt 1, alt-rhs] ; case-split-inline 'a
    { case-alt 0 ; any-call (unfold 'f) ; simplify
      any-call (unfold origwork)
      any-call (foreward (ww-assumption-A [| wrap |] [| unwrap |]))
      any-call (unfold 'f)
      simplify
      any-call (unfold-rule "[] ++")
      any-call (unfold-rule "++ []")
    }
    { case-alt 1 ; any-call (unfold 'f) ; simplify

      any-call (unfold origwork)
      any-call (foreward (ww-assumption-A [| wrap |] [| unwrap |]))
      any-call (unfold 'f)
      innermost let-subst ; simplify

      -- recursion decrements by two, so must do this again
      any-call (unfold origwork)
      any-call (foreward (ww-assumption-A [| wrap |] [| unwrap |]))

      -- time to let intro
      -- need a "occurance 'work" like consider
      { alt-rhs
        { app-arg
          { [app-fun, app-arg]
            { [app-fun, app-arg] ; let-intro 'u }
            { [app-arg, app-arg] ; let-intro 'v }
          }
          { [app-arg, app-arg, app-fun, app-arg] ; let-intro 'w }
        }
        innermost let-float
        try (reorder-lets ['u,'v,'w])
        any-call (fold 'u)
        any-call (fold 'v)
        any-call (fold 'w)
        let-tuple 'uvw
        any-call (fold 'unwrap)
        any-call (fold origwork)
      }
    }
  }
}
innermost dead-let-elimination
