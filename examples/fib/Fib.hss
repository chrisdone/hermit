-- not sure why unwrap is getting eta-expanded
consider 'unwrap
simplify
top

-- do the w/w split
consider 'fib
load "WWSplitTactic.hss"

-- now ready to start neil's derivation
rhs-of 'work

-- save this for later
up
stash-defn origwork
down

-- work = unwrap (f (wrap work))
--   extensionality (eta-expand)
eta-expand 'n

-- work n = unwrap (f (wrap work)) n
--   unfold 'unwrap
0; unfold 'unwrap

-- work n = (f (wrap work) n, f (wrap work) (n+1))
--   case 'n
case-split-inline 'n

-- work 0     = (f (wrap work) 0, f (wrap work) 1)
-- work (n+1) = (f (wrap work) (n+1), f (wrap work) (n+2))
--   unfold 'f
{ 1 ; any-call (unfold 'f); simplify }
2 ; 0  -- we're working in the n+1 rhs for a while
  { 1
    any-bu (unfold 'f)
    simplify

    -- work 0     = (0, 1)
    -- work (n+1) = (f (wrap work) (n+1), wrap work (n+1) + wrap work n)
    --   unfold 'work
    any-bu (stash-apply origwork)

    -- work 0     = (0, 1)
    -- work (n+1) = (f (wrap work) (n+1), wrap (unwrap (f (wrap work))) (n+1) + wrap (unwrap (f (wrap work))) n)
    --   wrap . unwrap = id (precondition)
    any-bu (unfold-rule precondition)

    -- work 0     = (0, 1)
    -- work (n+1) = (f (wrap work) (n+1), f (wrap work) (n+1) + f (wrap work) n)
    --   let-intro x2, let-float-tuple
    { 1 ; let-intro 'x }
  }

  { 0 ; 1 ; let-intro 'y }
  innermost (let-float-arg <+ let-float-app)
  { 1 ; 1 ; any-bu (fold 'y) }
  let-tuple 't

-- work 0     = (0, 1)
-- work (n+1) = let (x,y) = (f (wrap work) n, f (wrap work) (n+1)) in (y,x+y)
--   fold 'unwrap
  { rhs-of 't ; fold 'unwrap }

-- work 0     = (0, 1)
-- work (n+1) = let (x,y) = unwrap (f (wrap work)) n in (y,x+y)
--   fold 'work
-- work 0     = (0, 1)
-- work (n+1) = let (x,y) = work n in (y,x+y)

