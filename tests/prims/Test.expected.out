compiling Test.hs, using (Test.hs,Test.hss resume)
ghc-7.4.1 Test.hs     -fforce-recomp -O2 -dcore-lint -fsimple-list-literals -v0 -fplugin=HERMIT -fplugin-opt=HERMIT:main:Main:Test.hss -fplugin-opt=HERMIT:main:Main:resume -fplugin-opt=HERMIT:main:Main: 
["main:Main:","main:Main:resume","main:Main:Test.hss"]
("files",["","resume","Test.hss"])
0
[including Test.hss]
module main:Main where
  $dShow :: Show [] Char
  main :: IO ()
  beta_reduce_start :: Int
  beta_reduce_end :: Int
  case_reduce_start :: String
  case_reduce_end :: String
  main :: IO ()

module main:Main where
  $dShow :: Show [] Char
  main :: IO ()
  beta_reduce_start :: Int
  beta_reduce_end :: Int
  case_reduce_start :: String
  case_reduce_end :: String
  main :: IO ()

(\ x -> (+) * $fNumInt x (I# 2)) (I# 1)

let x = I# 1 in (+) * $fNumInt x (I# 2)

(+) * $fNumInt (I# 1) (I# 2)

module main:Main where
  $dShow :: Show [] Char
  main :: IO ()
  beta_reduce_start :: Int
  beta_reduce_end :: Int
  case_reduce_start :: String
  case_reduce_end :: String
  main :: IO ()

beta_reduce_start and beta_reduce_end are equal
module main:Main where
  $dShow :: Show [] Char
  main :: IO ()
  beta_reduce_start :: Int
  beta_reduce_end :: Int
  case_reduce_start :: String
  case_reduce_end :: String
  main :: IO ()

let bar = Bar (I# 5) (F# (__float 2.1))
in case bar of wild
     Bar x f -> show * $fShowInt x
     Baz s -> s

case Bar (I# 5) (F# (__float 2.1)) of wild
  Bar x f -> show * $fShowInt x
  Baz s -> s

show * $fShowInt (I# 5)

module main:Main where
  $dShow :: Show [] Char
  main :: IO ()
  beta_reduce_start :: Int
  beta_reduce_end :: Int
  case_reduce_start :: String
  case_reduce_end :: String
  main :: IO ()

case_reduce_start and case_reduce_end are equal
